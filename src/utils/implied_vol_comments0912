def implied_vol(F, K, T, r, market_price, threshold, sigma, option_type="call"):
    unfavourable = False
    #d1 = d1(F, K, T, sigma) if we make function public could use that instead of equation
    d1 = (np.log(F / K) + 0.5 * sigma**2 * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    # Condition 1- Deep in money calls (F>>K)
    x = np.log(F / K)
    if option_type == "call" and x > 0.5:
        unfavourable = True
    if option_type == "put" and x < -0.5:
        unfavourable = True

    # Condition 2- Short maturity time
    if T < 0.01:
        unfavourable = True

     # Condition 3- d1, d2 large
    if abs(d1) > threshold:
        unfavourable = True
        # add solution
    if abs(d2) > threshold:
        unfavourable = True
        # add solution

    #if unfavourable:
     #   print('Unfavourable')
     # then insert solution for each condition

    
    def f_sigma(sigma):
        if option_type == "call":
            return bs_call(F, K, T, sigma, r) - market_price
        else:
            return bs_put(F, K, T, sigma, r) - market_price

    return brentq(f_sigma, 1e-10, 5)
